1) Numerical Interpolation 수치 보간법
f(x) = 1/(1+16*x**2) [-1,1]
1_1
from numpy import linspace
from scipy.interpolate import lagrange
import matplotlib.pyplot as plt

def f(x):
        return 1 / (1 + 16*x**2)

def lagrange_interpolation(x_nodes, y_nodes,x):
    n = len(x_nodes)
    p = 0
    for j in range(n):
        L = 1 # L(x)는 여러항을 곱해서 만들었으므로 , 곱셈 항의 초기값
        for i in range(n):
            if i != j: #개념 식 조건
                L  *= (x-x_nodes[i])/(x_nodes[j]-x_nodes[i])
        p += y_nodes[j]* L
    return p

h = 0.2
x_start = -1
x_fin= 1
n_count = int((x_fin - x_start) / h + 1)
x_nodes = linspace(-1,1,n_count)
y_nodes = f(x_nodes)

x_plot = linspace(-1,1,200)
y_plot = f(x_plot)

p_polynomial = []
for x in x_plot:
    p_polynomial.append(lagrange_interpolation(x_nodes,y_nodes,x))

plt.plot(x_plot,y_plot,'r--',label='f(x)')
plt.plot(x_plot,p_polynomial,'b',label='P(x)')
plt.plot(x_nodes,y_nodes,'go')
plt.title('Lagrange interpolating polynomial p(x)',loc = 'center')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)
plt.show()

# ===========================================

1_2
from numpy import linspace,cos,pi,array
import matplotlib.pyplot as plt
from scipy.interpolate import lagrange

def f(x):
    return 1 / (1 + 16*x**2)

x_cheb_list=[]
n = 10
for i in range(n+1):
    x_i = cos((2*i+1)*pi/(2*n+2))
    x_cheb_list.append(x_i)

x_cheb = array(x_cheb_list) #f(x)를 계산하기 위해선 array()로 자료형을 바꿔줘야함. 파이썬 리스트는 벡터 연산을 하지 못함.
y_cheb = f(x_cheb)

def lagrange_interpolate(x_cheb,y_cheb,x):
    n = len(x_cheb)
    p = 0
    for j in range(n):
        L = 1
        for i in range(n):
            if i != j:
                 L  *= (x-x_cheb[i])/(x_cheb[j]-x_cheb[i])
        p += y_cheb[j]* L
    return p

x_plot = linspace(-1,1,200)
y_plot = f(x_plot)

p_y_cheb=[]
for x in x_plot:
    p_y_cheb.append(lagrange_interpolate(x_cheb,y_cheb,x))

plt.plot(x_plot,y_plot,'r--',label = 'f(x)')
plt.plot(x_plot,p_y_cheb,'b-',label='p(x)')
plt.plot(x_cheb,y_cheb,'go')
plt.title('Lagrange interpolate use Chebyshev nodes', loc='center')
plt.legend()
plt.grid(True)
plt.show()


# ==================================================================================
# 고차 다항식 보간에서는 Runge 현상이 흔히 발생
# 이는 보간 과정에서 발생하는 수치적 불안정성, 특히 uniform grid에서 더욱 두드러짐.
# Runge 현상: 보간 다항식이 구간의 양끝에서 과도하게 진동하는 것.
# 이를 보안하기 위해 Chebyshev node를 사용함으로써, 구간의 양끝에서 과도하게 진동하는 것을 줄임.
# 진동현상은 고차로 갈수록 심해짐.
1_3

from numpy import *
import matplotlib.pyplot as plt

n = 10
x_plot = linspace(-1,1,200)

x_uniform = linspace(-1,1,11)
x_chebyshev = [cos((2*i + 1) * pi / (2*n + 2)) for i in range(n+1)]

def multi_better(x_array,nodes):
    y = []
    for x in x_array:
        L = 1
        for xi in nodes:
            L *= abs(x - xi)
        y.append(L)
    return y

y_uniform = multi_better(x_plot,x_uniform)
y_chebyshev = multi_better(x_plot, x_chebyshev)


plt.plot(x_uniform,[0]*len(x_uniform),'ro',label='uniform')
plt.plot(x_chebyshev,[0]*len(x_chebyshev),'b^',label='chebyshev')
plt.plot(x_plot,y_uniform,'r--',label='uniform multi')
plt.plot(x_plot,y_chebyshev,'b-',label='chebyshev multi')
plt.legend()
plt.show()

# ============================================================
# 시각화: |w(x)| = |∏(x - x_i)| 를 그래프로 표현했을 때 얻을 수 있는 것.
# ============================================================
# 
# 1. Uniform Node
# - |w(x)| 값이 구간 양 끝에서 매우 크게 튀어오름
# - → 보간 오차가 양 끝에서 커지고 진동이 발생함 (Runge 현상)
# 
# 2. Chebyshev Node
# - |w(x)| 값이 전체 구간에서 훨씬 작고 균일하게 유지됨
# - → 보간 오차가 전체적으로 작고 안정적임
# - → 특히 구간 끝점에서 진동 억제 효과가 뛰어남
# 
# 따라서, Chebyshev 노드는 고차 보간에서도 안정적인 다항식 근사를 가능하게 해줌

#=====================================================================
# 2-4

from numpy import *
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

def f(x):
    return 1/ (1 + 16*x**2)

n = 10
x_plot = linspace(-1,1,200)
y_plot = f(x_plot)

def lagrange_interpolation(x_nodes,y_nodes,x_values):
    x_values = array(x_values)
    y_interp =zeros_like(x_values,dtype=float)
    n = len(x_nodes)

    for j in range(n):
        L = ones_like(x_values, dtype=float)
        for i in range(n):
             if i != j:
                 L *= (x_values - x_nodes[i])/(x_nodes[i] - x_nodes[j])
        y_interp += y_nodes[j] * L
    return y_interp



x_uni = linspace(-1,1,11)
y_uni = f(x_uni)
y_lagrange_uni = lagrange_interpolation(x_uni,y_uni,x_plot)

x_cheb = sort(array([cos((2*i+1)*pi/(2*n+2)) for i in range(n+1)]))
y_cheb = f(x_cheb)
y_lagrange_cheb = lagrange_interpolation(x_cheb,y_cheb,x_plot)

cs_uni = CubicSpline(x_uni,y_uni, bc_type= 'natural')  #Cubic 보간 함수 생성
cs_cheb = CubicSpline(x_cheb,y_cheb, bc_type= 'natural')

y_spline_uni = cs_uni(x_plot)
y_spline_cheb = cs_cheb(x_plot)

#bc_type = 'natural' == bc_type=((2,0),(2,0))
#bc_type = 'natural' -> 양 끝 노드 2번 미분값 = 0 조건임.
#다른 타입을 통해 양쪽 1차 도함수 또는 2차 도함수 값을 지정해줄 수 있다.

plt.plot(x_plot,y_plot,'k--',label = 'f(x)')
plt.plot(x_plot,y_spline_uni,'r-',label = 'Cubic Spline(Uniform)')
plt.plot(x_plot,y_lagrange_uni,'gold',label = 'lagrange interpolate(Uniform)')
plt.plot(x_uni,y_uni,'ro',label = 'Uniform nodes')
plt.plot(x_plot,y_spline_cheb,'b-',label = 'Cubic Spline(Chebyshev)')
plt.plot(x_plot,y_lagrange_cheb,'g-',label = 'lagrange interpolate(Chebyshev')
plt.plot(x_cheb,y_cheb,'bo',label = 'Chebyshev nodes')
plt.title('Cubic Spline interpolation')
plt.legend(fontsize='6')
plt.grid(True)
plt.show()

# ==============================================================================
# 2-5

# error analysis


from numpy import *
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

def f(x):
    return 1/ (1 + 16*x**2)

n = 10
x_plot = linspace(-1,1,200)
y_plot = f(x_plot)

def lagrange_interpolation(x_nodes,y_nodes,x_values):
    x_values = array(x_values)
    y_interp =zeros_like(x_values,dtype=float)
    n = len(x_nodes)

    for j in range(n):
        L = ones_like(x_values, dtype=float)
        for i in range(n):
             if i != j:
                 L *= (x_values - x_nodes[i])/(x_nodes[i] - x_nodes[j])
        y_interp += y_nodes[j] * L
    return y_interp


x_cheb = sort(array([cos((2*i+1)*pi/(2*n+2)) for i in range(n+1)]))
y_cheb = f(x_cheb)
y_lagrange_cheb = lagrange_interpolation(x_cheb,y_cheb,x_plot)


cs_cheb = CubicSpline(x_cheb,y_cheb, bc_type= 'natural')
y_spline_cheb = cs_cheb(x_plot)

error_lagrange = y_plot - y_lagrange_cheb
error_spline = y_plot - y_spline_cheb
abs_error_lagrange = abs(y_plot - y_lagrange_cheb)
abs_error_spline = abs(y_plot - y_spline_cheb)

max_error_lagrange = max(error_lagrange)
max_error_spline = max(error_spline)


# plt.plot(x_plot, error_lagrange, 'r-', label='Lagrange Error')
# plt.plot(x_plot, error_spline, 'b-', label='Spline Error')
plt.plot(x_plot, abs_error_lagrange, 'r--', label='Absolute Error')
plt.plot(x_plot, abs_error_spline, 'b--', label='Spline Error')
plt.title('Error Comparison (Chebyshev nodes)')
plt.xlabel('x')
plt.ylabel('Absolute Error')
plt.legend()
plt.grid(True)
plt.show()

print(max_error_lagrange)
print(max_error_spline)

# =====================================================================
'''Chebyshev 노드를 사용하여 Lagrange 보간과 Cubic Spline 보간을 적용한 결과,
Cubic Spline 보간이 Exact Solution과 가장 유사한 근사 결과를 보였으며,
전체 오차도 Lagrange 보간보다 더 작고 안정적이었다.

그래프를 통해 확인해보면,
Lagrange 보간은 전반적으로 오차가 크고 진동하는 경향을 보였으며,
특히 고차 다항식 보간에서 흔히 나타나는 **Runge 현상(경계 부근에서의 급격한 진동과 오차 증가)**이 일부 관찰되었다.

반면, Cubic Spline 보간은 오차가 작고 곡선이 부드럽게 변화하였으며,
경계 근처에서도 안정적인 보간 결과를 보여주었다.
최대 오차 또한 Lagrange 보간보다 작았다.

결론적으로, Chebyshev 노드는 Runge 현상을 완화하는 데 효과적이며,
특히 Cubic Spline 보간은 오차가 작고 안정성이 높아 Lagrange 보간보다 더 신뢰할 수 있는 방법임을 확인할 수 있다.'''
